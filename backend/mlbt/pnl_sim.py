# AUTOGENERATED! DO NOT EDIT! File to edit: dev/13_pnl_sim.ipynb (unless otherwise specified).

__all__ = ['long_short_strongest_signals', 'get_pnl_reports', 'discrete_signal', 'STEP_SIZE']

# Cell

import logging
import numpy as np
import pandas as pd

STEP_SIZE = 0.05
from mlfinlab.bet_sizing.ch10_snippets import get_signal


def long_short_strongest_signals(df, n):
    values = df.values
    # Impute nans to 0 so numpy doesn't sort them to the top
    values[np.isnan(values)] = 0

    sorty = values.argsort()

    shorts = pd.DataFrame(sorty[:, :n])
    longs = pd.DataFrame(sorty[:, -n:])

    shorts_s = shorts.apply(lambda x:df.columns[x])
    longs_s = longs.apply(lambda x:df.columns[x])

    la = longs_s.apply(lambda x: ','.join(x), axis=1).str.get_dummies(sep=',')
    sa = -shorts_s.apply(lambda x: ','.join(x), axis=1).str.get_dummies(sep=',')

    XX = la[la != 0].combine_first(sa[sa != 0])

    XX = XX.set_index(df.index)
    XX = XX.reindex(columns=df.columns)

    return XX.fillna(0)

def get_pnl_reports(events, symbols, binarize, binarize_params):
    """Groups our grand frames by symbol and extracts the average active signal that we'll use to trade later"""
    closes = []
    clf_signals = []
    alpha_signals = []
    logging.info(
        f"Generating signals for {len(symbols)} symbols on {len(events)} events with b_params={binarize_params}"
    )

    for key, group in events.groupby(events.index.microsecond):
        symbol = symbols[key]
        close = group["close_p"]
        close.name = symbol
        closes.append(close)
        if "side" in group:
            # Meta-labeling
            alpha_s = group["side"]
            alpha_s.name = symbol
            alpha_signals.append(alpha_s)
            signal = group["y_pred"] * group["side"]
        else:
            signal = group["y_pred"]

        pred, prob = group['y_pred'], group['y_pred_proba']

        clf_s = get_signal(prob.where(prob >= 0.5, 1 - prob), 2, pred)

        clf_s.name = symbol
        clf_signals.append(clf_s)

    closes = pd.concat(closes, axis=1).ffill()
    clf_signals = pd.concat(clf_signals, axis=1).ffill()

    clf_signals = long_short_strongest_signals(clf_signals, n=20)

    new_df = pd.DataFrame(index=clf_signals.index, columns=clf_signals.columns)
    for key, group in clf_signals.groupby(clf_signals.index.microsecond):
        symbol = symbols[key]
        new_df.loc[group.index, symbol] = group[symbol].rolling(binarize_params).mean()

    # Limit any signal to a runway of 2% of the total length (roughly 1 month over 5 years)
    clf_signals = new_df.ffill(limit=int(new_df.shape[0] * 0.02)).fillna(0)
    clf_signals = discrete_signal(clf_signals, STEP_SIZE)

    if "side" in events:
        alpha_signals = pd.concat(alpha_signals, axis=1).ffill()
    else:
        alpha_signals = None

    return closes, clf_signals, alpha_signals


def discrete_signal(signal0, step_size):
    # discretize signal
    signal1 = (signal0 / step_size).round() * step_size
    return signal1.clip(-1, 1)